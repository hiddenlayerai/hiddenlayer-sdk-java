/*
 * HiddenLayer ModelScan V2
 * HiddenLayer ModelScan API for scanning of models
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.hiddenlayer.sdk.rest.models;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.hiddenlayer.sdk.rest.models.ArtifactLocation;
import com.hiddenlayer.sdk.rest.models.MultiformatMessageString;
import com.hiddenlayer.sdk.rest.models.PropertyBag;
import com.hiddenlayer.sdk.rest.models.ReportingDescriptor;
import com.hiddenlayer.sdk.rest.models.ToolComponentReference;
import com.hiddenlayer.sdk.rest.models.TranslationMetadata;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * A component, such as a plug-in or the driver, of the analysis tool that was run.
 */
@JsonPropertyOrder({
  ToolComponent.JSON_PROPERTY_GUID,
  ToolComponent.JSON_PROPERTY_NAME,
  ToolComponent.JSON_PROPERTY_ORGANIZATION,
  ToolComponent.JSON_PROPERTY_PRODUCT,
  ToolComponent.JSON_PROPERTY_PRODUCT_SUITE,
  ToolComponent.JSON_PROPERTY_SHORT_DESCRIPTION,
  ToolComponent.JSON_PROPERTY_FULL_DESCRIPTION,
  ToolComponent.JSON_PROPERTY_FULL_NAME,
  ToolComponent.JSON_PROPERTY_VERSION,
  ToolComponent.JSON_PROPERTY_SEMANTIC_VERSION,
  ToolComponent.JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION,
  ToolComponent.JSON_PROPERTY_RELEASE_DATE_UTC,
  ToolComponent.JSON_PROPERTY_DOWNLOAD_URI,
  ToolComponent.JSON_PROPERTY_INFORMATION_URI,
  ToolComponent.JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS,
  ToolComponent.JSON_PROPERTY_NOTIFICATIONS,
  ToolComponent.JSON_PROPERTY_RULES,
  ToolComponent.JSON_PROPERTY_TAXA,
  ToolComponent.JSON_PROPERTY_LOCATIONS,
  ToolComponent.JSON_PROPERTY_LANGUAGE,
  ToolComponent.JSON_PROPERTY_CONTENTS,
  ToolComponent.JSON_PROPERTY_IS_COMPREHENSIVE,
  ToolComponent.JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION,
  ToolComponent.JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION,
  ToolComponent.JSON_PROPERTY_ASSOCIATED_COMPONENT,
  ToolComponent.JSON_PROPERTY_TRANSLATION_METADATA,
  ToolComponent.JSON_PROPERTY_SUPPORTED_TAXONOMIES,
  ToolComponent.JSON_PROPERTY_PROPERTIES
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-12-30T18:04:47.686514Z[GMT]", comments = "Generator version: 7.6.0")
public class ToolComponent {
  public static final String JSON_PROPERTY_GUID = "guid";
  private String guid;

  public static final String JSON_PROPERTY_NAME = "name";
  private String name;

  public static final String JSON_PROPERTY_ORGANIZATION = "organization";
  private String organization;

  public static final String JSON_PROPERTY_PRODUCT = "product";
  private String product;

  public static final String JSON_PROPERTY_PRODUCT_SUITE = "productSuite";
  private String productSuite;

  public static final String JSON_PROPERTY_SHORT_DESCRIPTION = "shortDescription";
  private MultiformatMessageString shortDescription;

  public static final String JSON_PROPERTY_FULL_DESCRIPTION = "fullDescription";
  private MultiformatMessageString fullDescription;

  public static final String JSON_PROPERTY_FULL_NAME = "fullName";
  private String fullName;

  public static final String JSON_PROPERTY_VERSION = "version";
  private String version;

  public static final String JSON_PROPERTY_SEMANTIC_VERSION = "semanticVersion";
  private String semanticVersion;

  public static final String JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION = "dottedQuadFileVersion";
  private String dottedQuadFileVersion;

  public static final String JSON_PROPERTY_RELEASE_DATE_UTC = "releaseDateUtc";
  private String releaseDateUtc;

  public static final String JSON_PROPERTY_DOWNLOAD_URI = "downloadUri";
  private URI downloadUri;

  public static final String JSON_PROPERTY_INFORMATION_URI = "informationUri";
  private URI informationUri;

  public static final String JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS = "globalMessageStrings";
  private Map<String, MultiformatMessageString> globalMessageStrings = new HashMap<>();

  public static final String JSON_PROPERTY_NOTIFICATIONS = "notifications";
  private Set<ReportingDescriptor> notifications = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_RULES = "rules";
  private Set<ReportingDescriptor> rules = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_TAXA = "taxa";
  private Set<ReportingDescriptor> taxa = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_LOCATIONS = "locations";
  private List<ArtifactLocation> locations = new ArrayList<>();

  public static final String JSON_PROPERTY_LANGUAGE = "language";
  private String language = "en-US";

  /**
   * Gets or Sets contents
   */
  public enum ContentsEnum {
    LOCALIZEDDATA("localizedData"),
    
    NONLOCALIZEDDATA("nonLocalizedData");

    private String value;

    ContentsEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static ContentsEnum fromValue(String value) {
      for (ContentsEnum b : ContentsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_CONTENTS = "contents";
  private Set<ContentsEnum> contents = new LinkedHashSet<>(Arrays.asList(ContentsEnum.LOCALIZEDDATA, ContentsEnum.NONLOCALIZEDDATA));

  public static final String JSON_PROPERTY_IS_COMPREHENSIVE = "isComprehensive";
  private Boolean isComprehensive = false;

  public static final String JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION = "localizedDataSemanticVersion";
  private String localizedDataSemanticVersion;

  public static final String JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION = "minimumRequiredLocalizedDataSemanticVersion";
  private String minimumRequiredLocalizedDataSemanticVersion;

  public static final String JSON_PROPERTY_ASSOCIATED_COMPONENT = "associatedComponent";
  private ToolComponentReference associatedComponent;

  public static final String JSON_PROPERTY_TRANSLATION_METADATA = "translationMetadata";
  private TranslationMetadata translationMetadata;

  public static final String JSON_PROPERTY_SUPPORTED_TAXONOMIES = "supportedTaxonomies";
  private Set<ToolComponentReference> supportedTaxonomies = new LinkedHashSet<>();

  public static final String JSON_PROPERTY_PROPERTIES = "properties";
  private PropertyBag properties;

  public ToolComponent() { 
  }

  public ToolComponent guid(String guid) {
    this.guid = guid;
    return this;
  }

   /**
   * A unique identifier for the tool component in the form of a GUID.
   * @return guid
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_GUID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getGuid() {
    return guid;
  }


  @JsonProperty(JSON_PROPERTY_GUID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setGuid(String guid) {
    this.guid = guid;
  }


  public ToolComponent name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the tool component.
   * @return name
  **/
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(String name) {
    this.name = name;
  }


  public ToolComponent organization(String organization) {
    this.organization = organization;
    return this;
  }

   /**
   * The organization or company that produced the tool component.
   * @return organization
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ORGANIZATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getOrganization() {
    return organization;
  }


  @JsonProperty(JSON_PROPERTY_ORGANIZATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOrganization(String organization) {
    this.organization = organization;
  }


  public ToolComponent product(String product) {
    this.product = product;
    return this;
  }

   /**
   * A product suite to which the tool component belongs.
   * @return product
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PRODUCT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getProduct() {
    return product;
  }


  @JsonProperty(JSON_PROPERTY_PRODUCT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProduct(String product) {
    this.product = product;
  }


  public ToolComponent productSuite(String productSuite) {
    this.productSuite = productSuite;
    return this;
  }

   /**
   * A localizable string containing the name of the suite of products to which the tool component belongs.
   * @return productSuite
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PRODUCT_SUITE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getProductSuite() {
    return productSuite;
  }


  @JsonProperty(JSON_PROPERTY_PRODUCT_SUITE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProductSuite(String productSuite) {
    this.productSuite = productSuite;
  }


  public ToolComponent shortDescription(MultiformatMessageString shortDescription) {
    this.shortDescription = shortDescription;
    return this;
  }

   /**
   * Get shortDescription
   * @return shortDescription
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SHORT_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public MultiformatMessageString getShortDescription() {
    return shortDescription;
  }


  @JsonProperty(JSON_PROPERTY_SHORT_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setShortDescription(MultiformatMessageString shortDescription) {
    this.shortDescription = shortDescription;
  }


  public ToolComponent fullDescription(MultiformatMessageString fullDescription) {
    this.fullDescription = fullDescription;
    return this;
  }

   /**
   * Get fullDescription
   * @return fullDescription
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FULL_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public MultiformatMessageString getFullDescription() {
    return fullDescription;
  }


  @JsonProperty(JSON_PROPERTY_FULL_DESCRIPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFullDescription(MultiformatMessageString fullDescription) {
    this.fullDescription = fullDescription;
  }


  public ToolComponent fullName(String fullName) {
    this.fullName = fullName;
    return this;
  }

   /**
   * The name of the tool component along with its version and any other useful identifying information, such as its locale.
   * @return fullName
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_FULL_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getFullName() {
    return fullName;
  }


  @JsonProperty(JSON_PROPERTY_FULL_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFullName(String fullName) {
    this.fullName = fullName;
  }


  public ToolComponent version(String version) {
    this.version = version;
    return this;
  }

   /**
   * The tool component version, in whatever format the component natively provides.
   * @return version
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getVersion() {
    return version;
  }


  @JsonProperty(JSON_PROPERTY_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVersion(String version) {
    this.version = version;
  }


  public ToolComponent semanticVersion(String semanticVersion) {
    this.semanticVersion = semanticVersion;
    return this;
  }

   /**
   * The tool component version in the format specified by Semantic Versioning 2.0.
   * @return semanticVersion
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSemanticVersion() {
    return semanticVersion;
  }


  @JsonProperty(JSON_PROPERTY_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSemanticVersion(String semanticVersion) {
    this.semanticVersion = semanticVersion;
  }


  public ToolComponent dottedQuadFileVersion(String dottedQuadFileVersion) {
    this.dottedQuadFileVersion = dottedQuadFileVersion;
    return this;
  }

   /**
   * The binary version of the tool component&#39;s primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).
   * @return dottedQuadFileVersion
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getDottedQuadFileVersion() {
    return dottedQuadFileVersion;
  }


  @JsonProperty(JSON_PROPERTY_DOTTED_QUAD_FILE_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDottedQuadFileVersion(String dottedQuadFileVersion) {
    this.dottedQuadFileVersion = dottedQuadFileVersion;
  }


  public ToolComponent releaseDateUtc(String releaseDateUtc) {
    this.releaseDateUtc = releaseDateUtc;
    return this;
  }

   /**
   * A string specifying the UTC date (and optionally, the time) of the component&#39;s release.
   * @return releaseDateUtc
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RELEASE_DATE_UTC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getReleaseDateUtc() {
    return releaseDateUtc;
  }


  @JsonProperty(JSON_PROPERTY_RELEASE_DATE_UTC)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReleaseDateUtc(String releaseDateUtc) {
    this.releaseDateUtc = releaseDateUtc;
  }


  public ToolComponent downloadUri(URI downloadUri) {
    this.downloadUri = downloadUri;
    return this;
  }

   /**
   * The absolute URI from which the tool component can be downloaded.
   * @return downloadUri
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_DOWNLOAD_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public URI getDownloadUri() {
    return downloadUri;
  }


  @JsonProperty(JSON_PROPERTY_DOWNLOAD_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDownloadUri(URI downloadUri) {
    this.downloadUri = downloadUri;
  }


  public ToolComponent informationUri(URI informationUri) {
    this.informationUri = informationUri;
    return this;
  }

   /**
   * The absolute URI at which information about this version of the tool component can be found.
   * @return informationUri
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_INFORMATION_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public URI getInformationUri() {
    return informationUri;
  }


  @JsonProperty(JSON_PROPERTY_INFORMATION_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInformationUri(URI informationUri) {
    this.informationUri = informationUri;
  }


  public ToolComponent globalMessageStrings(Map<String, MultiformatMessageString> globalMessageStrings) {
    this.globalMessageStrings = globalMessageStrings;
    return this;
  }

  public ToolComponent putGlobalMessageStringsItem(String key, MultiformatMessageString globalMessageStringsItem) {
    if (this.globalMessageStrings == null) {
      this.globalMessageStrings = new HashMap<>();
    }
    this.globalMessageStrings.put(key, globalMessageStringsItem);
    return this;
  }

   /**
   * A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.
   * @return globalMessageStrings
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, MultiformatMessageString> getGlobalMessageStrings() {
    return globalMessageStrings;
  }


  @JsonProperty(JSON_PROPERTY_GLOBAL_MESSAGE_STRINGS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setGlobalMessageStrings(Map<String, MultiformatMessageString> globalMessageStrings) {
    this.globalMessageStrings = globalMessageStrings;
  }


  public ToolComponent notifications(Set<ReportingDescriptor> notifications) {
    this.notifications = notifications;
    return this;
  }

  public ToolComponent addNotificationsItem(ReportingDescriptor notificationsItem) {
    if (this.notifications == null) {
      this.notifications = new LinkedHashSet<>();
    }
    this.notifications.add(notificationsItem);
    return this;
  }

   /**
   * An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.
   * @return notifications
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NOTIFICATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<ReportingDescriptor> getNotifications() {
    return notifications;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_NOTIFICATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setNotifications(Set<ReportingDescriptor> notifications) {
    this.notifications = notifications;
  }


  public ToolComponent rules(Set<ReportingDescriptor> rules) {
    this.rules = rules;
    return this;
  }

  public ToolComponent addRulesItem(ReportingDescriptor rulesItem) {
    if (this.rules == null) {
      this.rules = new LinkedHashSet<>();
    }
    this.rules.add(rulesItem);
    return this;
  }

   /**
   * An array of reportingDescriptor objects relevant to the analysis performed by the tool component.
   * @return rules
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RULES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<ReportingDescriptor> getRules() {
    return rules;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_RULES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRules(Set<ReportingDescriptor> rules) {
    this.rules = rules;
  }


  public ToolComponent taxa(Set<ReportingDescriptor> taxa) {
    this.taxa = taxa;
    return this;
  }

  public ToolComponent addTaxaItem(ReportingDescriptor taxaItem) {
    if (this.taxa == null) {
      this.taxa = new LinkedHashSet<>();
    }
    this.taxa.add(taxaItem);
    return this;
  }

   /**
   * An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.
   * @return taxa
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TAXA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<ReportingDescriptor> getTaxa() {
    return taxa;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_TAXA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTaxa(Set<ReportingDescriptor> taxa) {
    this.taxa = taxa;
  }


  public ToolComponent locations(List<ArtifactLocation> locations) {
    this.locations = locations;
    return this;
  }

  public ToolComponent addLocationsItem(ArtifactLocation locationsItem) {
    if (this.locations == null) {
      this.locations = new ArrayList<>();
    }
    this.locations.add(locationsItem);
    return this;
  }

   /**
   * An array of the artifactLocation objects associated with the tool component.
   * @return locations
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOCATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ArtifactLocation> getLocations() {
    return locations;
  }


  @JsonProperty(JSON_PROPERTY_LOCATIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLocations(List<ArtifactLocation> locations) {
    this.locations = locations;
  }


  public ToolComponent language(String language) {
    this.language = language;
    return this;
  }

   /**
   * The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).
   * @return language
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LANGUAGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getLanguage() {
    return language;
  }


  @JsonProperty(JSON_PROPERTY_LANGUAGE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLanguage(String language) {
    this.language = language;
  }


  public ToolComponent contents(Set<ContentsEnum> contents) {
    this.contents = contents;
    return this;
  }

  public ToolComponent addContentsItem(ContentsEnum contentsItem) {
    if (this.contents == null) {
      this.contents = new LinkedHashSet<>(Arrays.asList(ContentsEnum.LOCALIZEDDATA, ContentsEnum.NONLOCALIZEDDATA));
    }
    this.contents.add(contentsItem);
    return this;
  }

   /**
   * The kinds of data contained in this object.
   * @return contents
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_CONTENTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<ContentsEnum> getContents() {
    return contents;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_CONTENTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContents(Set<ContentsEnum> contents) {
    this.contents = contents;
  }


  public ToolComponent isComprehensive(Boolean isComprehensive) {
    this.isComprehensive = isComprehensive;
    return this;
  }

   /**
   * Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.
   * @return isComprehensive
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_IS_COMPREHENSIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getIsComprehensive() {
    return isComprehensive;
  }


  @JsonProperty(JSON_PROPERTY_IS_COMPREHENSIVE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIsComprehensive(Boolean isComprehensive) {
    this.isComprehensive = isComprehensive;
  }


  public ToolComponent localizedDataSemanticVersion(String localizedDataSemanticVersion) {
    this.localizedDataSemanticVersion = localizedDataSemanticVersion;
    return this;
  }

   /**
   * The semantic version of the localized strings defined in this component; maintained by components that provide translations.
   * @return localizedDataSemanticVersion
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getLocalizedDataSemanticVersion() {
    return localizedDataSemanticVersion;
  }


  @JsonProperty(JSON_PROPERTY_LOCALIZED_DATA_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLocalizedDataSemanticVersion(String localizedDataSemanticVersion) {
    this.localizedDataSemanticVersion = localizedDataSemanticVersion;
  }


  public ToolComponent minimumRequiredLocalizedDataSemanticVersion(String minimumRequiredLocalizedDataSemanticVersion) {
    this.minimumRequiredLocalizedDataSemanticVersion = minimumRequiredLocalizedDataSemanticVersion;
    return this;
  }

   /**
   * The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.
   * @return minimumRequiredLocalizedDataSemanticVersion
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getMinimumRequiredLocalizedDataSemanticVersion() {
    return minimumRequiredLocalizedDataSemanticVersion;
  }


  @JsonProperty(JSON_PROPERTY_MINIMUM_REQUIRED_LOCALIZED_DATA_SEMANTIC_VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMinimumRequiredLocalizedDataSemanticVersion(String minimumRequiredLocalizedDataSemanticVersion) {
    this.minimumRequiredLocalizedDataSemanticVersion = minimumRequiredLocalizedDataSemanticVersion;
  }


  public ToolComponent associatedComponent(ToolComponentReference associatedComponent) {
    this.associatedComponent = associatedComponent;
    return this;
  }

   /**
   * Get associatedComponent
   * @return associatedComponent
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ASSOCIATED_COMPONENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ToolComponentReference getAssociatedComponent() {
    return associatedComponent;
  }


  @JsonProperty(JSON_PROPERTY_ASSOCIATED_COMPONENT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAssociatedComponent(ToolComponentReference associatedComponent) {
    this.associatedComponent = associatedComponent;
  }


  public ToolComponent translationMetadata(TranslationMetadata translationMetadata) {
    this.translationMetadata = translationMetadata;
    return this;
  }

   /**
   * Get translationMetadata
   * @return translationMetadata
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRANSLATION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TranslationMetadata getTranslationMetadata() {
    return translationMetadata;
  }


  @JsonProperty(JSON_PROPERTY_TRANSLATION_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTranslationMetadata(TranslationMetadata translationMetadata) {
    this.translationMetadata = translationMetadata;
  }


  public ToolComponent supportedTaxonomies(Set<ToolComponentReference> supportedTaxonomies) {
    this.supportedTaxonomies = supportedTaxonomies;
    return this;
  }

  public ToolComponent addSupportedTaxonomiesItem(ToolComponentReference supportedTaxonomiesItem) {
    if (this.supportedTaxonomies == null) {
      this.supportedTaxonomies = new LinkedHashSet<>();
    }
    this.supportedTaxonomies.add(supportedTaxonomiesItem);
    return this;
  }

   /**
   * An array of toolComponentReference objects to declare the taxonomies supported by the tool component.
   * @return supportedTaxonomies
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SUPPORTED_TAXONOMIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Set<ToolComponentReference> getSupportedTaxonomies() {
    return supportedTaxonomies;
  }


  @JsonDeserialize(as = LinkedHashSet.class)
  @JsonProperty(JSON_PROPERTY_SUPPORTED_TAXONOMIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSupportedTaxonomies(Set<ToolComponentReference> supportedTaxonomies) {
    this.supportedTaxonomies = supportedTaxonomies;
  }


  public ToolComponent properties(PropertyBag properties) {
    this.properties = properties;
    return this;
  }

   /**
   * Get properties
   * @return properties
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public PropertyBag getProperties() {
    return properties;
  }


  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProperties(PropertyBag properties) {
    this.properties = properties;
  }


  /**
   * Return true if this toolComponent object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ToolComponent toolComponent = (ToolComponent) o;
    return Objects.equals(this.guid, toolComponent.guid) &&
        Objects.equals(this.name, toolComponent.name) &&
        Objects.equals(this.organization, toolComponent.organization) &&
        Objects.equals(this.product, toolComponent.product) &&
        Objects.equals(this.productSuite, toolComponent.productSuite) &&
        Objects.equals(this.shortDescription, toolComponent.shortDescription) &&
        Objects.equals(this.fullDescription, toolComponent.fullDescription) &&
        Objects.equals(this.fullName, toolComponent.fullName) &&
        Objects.equals(this.version, toolComponent.version) &&
        Objects.equals(this.semanticVersion, toolComponent.semanticVersion) &&
        Objects.equals(this.dottedQuadFileVersion, toolComponent.dottedQuadFileVersion) &&
        Objects.equals(this.releaseDateUtc, toolComponent.releaseDateUtc) &&
        Objects.equals(this.downloadUri, toolComponent.downloadUri) &&
        Objects.equals(this.informationUri, toolComponent.informationUri) &&
        Objects.equals(this.globalMessageStrings, toolComponent.globalMessageStrings) &&
        Objects.equals(this.notifications, toolComponent.notifications) &&
        Objects.equals(this.rules, toolComponent.rules) &&
        Objects.equals(this.taxa, toolComponent.taxa) &&
        Objects.equals(this.locations, toolComponent.locations) &&
        Objects.equals(this.language, toolComponent.language) &&
        Objects.equals(this.contents, toolComponent.contents) &&
        Objects.equals(this.isComprehensive, toolComponent.isComprehensive) &&
        Objects.equals(this.localizedDataSemanticVersion, toolComponent.localizedDataSemanticVersion) &&
        Objects.equals(this.minimumRequiredLocalizedDataSemanticVersion, toolComponent.minimumRequiredLocalizedDataSemanticVersion) &&
        Objects.equals(this.associatedComponent, toolComponent.associatedComponent) &&
        Objects.equals(this.translationMetadata, toolComponent.translationMetadata) &&
        Objects.equals(this.supportedTaxonomies, toolComponent.supportedTaxonomies) &&
        Objects.equals(this.properties, toolComponent.properties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(guid, name, organization, product, productSuite, shortDescription, fullDescription, fullName, version, semanticVersion, dottedQuadFileVersion, releaseDateUtc, downloadUri, informationUri, globalMessageStrings, notifications, rules, taxa, locations, language, contents, isComprehensive, localizedDataSemanticVersion, minimumRequiredLocalizedDataSemanticVersion, associatedComponent, translationMetadata, supportedTaxonomies, properties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ToolComponent {\n");
    sb.append("    guid: ").append(toIndentedString(guid)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    organization: ").append(toIndentedString(organization)).append("\n");
    sb.append("    product: ").append(toIndentedString(product)).append("\n");
    sb.append("    productSuite: ").append(toIndentedString(productSuite)).append("\n");
    sb.append("    shortDescription: ").append(toIndentedString(shortDescription)).append("\n");
    sb.append("    fullDescription: ").append(toIndentedString(fullDescription)).append("\n");
    sb.append("    fullName: ").append(toIndentedString(fullName)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    semanticVersion: ").append(toIndentedString(semanticVersion)).append("\n");
    sb.append("    dottedQuadFileVersion: ").append(toIndentedString(dottedQuadFileVersion)).append("\n");
    sb.append("    releaseDateUtc: ").append(toIndentedString(releaseDateUtc)).append("\n");
    sb.append("    downloadUri: ").append(toIndentedString(downloadUri)).append("\n");
    sb.append("    informationUri: ").append(toIndentedString(informationUri)).append("\n");
    sb.append("    globalMessageStrings: ").append(toIndentedString(globalMessageStrings)).append("\n");
    sb.append("    notifications: ").append(toIndentedString(notifications)).append("\n");
    sb.append("    rules: ").append(toIndentedString(rules)).append("\n");
    sb.append("    taxa: ").append(toIndentedString(taxa)).append("\n");
    sb.append("    locations: ").append(toIndentedString(locations)).append("\n");
    sb.append("    language: ").append(toIndentedString(language)).append("\n");
    sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
    sb.append("    isComprehensive: ").append(toIndentedString(isComprehensive)).append("\n");
    sb.append("    localizedDataSemanticVersion: ").append(toIndentedString(localizedDataSemanticVersion)).append("\n");
    sb.append("    minimumRequiredLocalizedDataSemanticVersion: ").append(toIndentedString(minimumRequiredLocalizedDataSemanticVersion)).append("\n");
    sb.append("    associatedComponent: ").append(toIndentedString(associatedComponent)).append("\n");
    sb.append("    translationMetadata: ").append(toIndentedString(translationMetadata)).append("\n");
    sb.append("    supportedTaxonomies: ").append(toIndentedString(supportedTaxonomies)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `guid` to the URL query string
    if (getGuid() != null) {
      joiner.add(String.format("%sguid%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getGuid()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `name` to the URL query string
    if (getName() != null) {
      joiner.add(String.format("%sname%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getName()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `organization` to the URL query string
    if (getOrganization() != null) {
      joiner.add(String.format("%sorganization%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getOrganization()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `product` to the URL query string
    if (getProduct() != null) {
      joiner.add(String.format("%sproduct%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getProduct()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `productSuite` to the URL query string
    if (getProductSuite() != null) {
      joiner.add(String.format("%sproductSuite%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getProductSuite()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `shortDescription` to the URL query string
    if (getShortDescription() != null) {
      joiner.add(getShortDescription().toUrlQueryString(prefix + "shortDescription" + suffix));
    }

    // add `fullDescription` to the URL query string
    if (getFullDescription() != null) {
      joiner.add(getFullDescription().toUrlQueryString(prefix + "fullDescription" + suffix));
    }

    // add `fullName` to the URL query string
    if (getFullName() != null) {
      joiner.add(String.format("%sfullName%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getFullName()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `version` to the URL query string
    if (getVersion() != null) {
      joiner.add(String.format("%sversion%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `semanticVersion` to the URL query string
    if (getSemanticVersion() != null) {
      joiner.add(String.format("%ssemanticVersion%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getSemanticVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `dottedQuadFileVersion` to the URL query string
    if (getDottedQuadFileVersion() != null) {
      joiner.add(String.format("%sdottedQuadFileVersion%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getDottedQuadFileVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `releaseDateUtc` to the URL query string
    if (getReleaseDateUtc() != null) {
      joiner.add(String.format("%sreleaseDateUtc%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getReleaseDateUtc()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `downloadUri` to the URL query string
    if (getDownloadUri() != null) {
      joiner.add(String.format("%sdownloadUri%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getDownloadUri()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `informationUri` to the URL query string
    if (getInformationUri() != null) {
      joiner.add(String.format("%sinformationUri%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getInformationUri()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `globalMessageStrings` to the URL query string
    if (getGlobalMessageStrings() != null) {
      for (String _key : getGlobalMessageStrings().keySet()) {
        if (getGlobalMessageStrings().get(_key) != null) {
          joiner.add(getGlobalMessageStrings().get(_key).toUrlQueryString(String.format("%sglobalMessageStrings%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, _key, containerSuffix))));
        }
      }
    }

    // add `notifications` to the URL query string
    if (getNotifications() != null) {
      int i = 0;
      for (ReportingDescriptor _item : getNotifications()) {
        if (_item != null) {
          joiner.add(_item.toUrlQueryString(String.format("%snotifications%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
      i++;
    }

    // add `rules` to the URL query string
    if (getRules() != null) {
      int i = 0;
      for (ReportingDescriptor _item : getRules()) {
        if (_item != null) {
          joiner.add(_item.toUrlQueryString(String.format("%srules%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
      i++;
    }

    // add `taxa` to the URL query string
    if (getTaxa() != null) {
      int i = 0;
      for (ReportingDescriptor _item : getTaxa()) {
        if (_item != null) {
          joiner.add(_item.toUrlQueryString(String.format("%staxa%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
      i++;
    }

    // add `locations` to the URL query string
    if (getLocations() != null) {
      for (int i = 0; i < getLocations().size(); i++) {
        if (getLocations().get(i) != null) {
          joiner.add(getLocations().get(i).toUrlQueryString(String.format("%slocations%s%s", prefix, suffix,
          "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `language` to the URL query string
    if (getLanguage() != null) {
      joiner.add(String.format("%slanguage%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getLanguage()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `contents` to the URL query string
    if (getContents() != null) {
      int i = 0;
      for (ContentsEnum _item : getContents()) {
        joiner.add(String.format("%scontents%s%s=%s", prefix, suffix,
            "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix),
            URLEncoder.encode(String.valueOf(_item), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
      }
      i++;
    }

    // add `isComprehensive` to the URL query string
    if (getIsComprehensive() != null) {
      joiner.add(String.format("%sisComprehensive%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsComprehensive()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `localizedDataSemanticVersion` to the URL query string
    if (getLocalizedDataSemanticVersion() != null) {
      joiner.add(String.format("%slocalizedDataSemanticVersion%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getLocalizedDataSemanticVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `minimumRequiredLocalizedDataSemanticVersion` to the URL query string
    if (getMinimumRequiredLocalizedDataSemanticVersion() != null) {
      joiner.add(String.format("%sminimumRequiredLocalizedDataSemanticVersion%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getMinimumRequiredLocalizedDataSemanticVersion()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    // add `associatedComponent` to the URL query string
    if (getAssociatedComponent() != null) {
      joiner.add(getAssociatedComponent().toUrlQueryString(prefix + "associatedComponent" + suffix));
    }

    // add `translationMetadata` to the URL query string
    if (getTranslationMetadata() != null) {
      joiner.add(getTranslationMetadata().toUrlQueryString(prefix + "translationMetadata" + suffix));
    }

    // add `supportedTaxonomies` to the URL query string
    if (getSupportedTaxonomies() != null) {
      int i = 0;
      for (ToolComponentReference _item : getSupportedTaxonomies()) {
        if (_item != null) {
          joiner.add(_item.toUrlQueryString(String.format("%ssupportedTaxonomies%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
      i++;
    }

    // add `properties` to the URL query string
    if (getProperties() != null) {
      joiner.add(String.format("%sproperties%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getProperties()), StandardCharsets.UTF_8).replaceAll("\\+", "%20")));
    }

    return joiner.toString();
  }
}

